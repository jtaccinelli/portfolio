diff --git a/node_modules/nanoid/index.cjs b/node_modules/nanoid/index.cjs
index 0fa85e9..f800d6f 100644
--- a/node_modules/nanoid/index.cjs
+++ b/node_modules/nanoid/index.cjs
@@ -1,32 +1,15 @@
-let crypto = require('crypto')
 let { urlAlphabet } = require('./url-alphabet/index.cjs')
-const POOL_SIZE_MULTIPLIER = 128
-let pool, poolOffset
-let fillPool = bytes => {
-  if (!pool || pool.length < bytes) {
-    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)
-    crypto.randomFillSync(pool)
-    poolOffset = 0
-  } else if (poolOffset + bytes > pool.length) {
-    crypto.randomFillSync(pool)
-    poolOffset = 0
-  }
-  poolOffset += bytes
-}
-let random = bytes => {
-  fillPool((bytes -= 0))
-  return pool.subarray(poolOffset - bytes, poolOffset)
-}
+let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
 let customRandom = (alphabet, defaultSize, getRandom) => {
-  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
-  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)
+  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
+  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
   return (size = defaultSize) => {
     let id = ''
     while (true) {
       let bytes = getRandom(step)
-      let i = step
-      while (i--) {
-        id += alphabet[bytes[i] & mask] || ''
+      let j = step
+      while (j--) {
+        id += alphabet[bytes[j] & mask] || ''
         if (id.length === size) return id
       }
     }
@@ -34,12 +17,18 @@ let customRandom = (alphabet, defaultSize, getRandom) => {
 }
 let customAlphabet = (alphabet, size = 21) =>
   customRandom(alphabet, size, random)
-let nanoid = (size = 21) => {
-  fillPool((size -= 0))
-  let id = ''
-  for (let i = poolOffset - size; i < poolOffset; i++) {
-    id += urlAlphabet[pool[i] & 63]
-  }
-  return id
-}
+let nanoid = (size = 21) =>
+  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
+    byte &= 63
+    if (byte < 36) {
+      id += byte.toString(36)
+    } else if (byte < 62) {
+      id += (byte - 26).toString(36).toUpperCase()
+    } else if (byte > 62) {
+      id += '-'
+    } else {
+      id += '_'
+    }
+    return id
+  }, '')
 module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }
diff --git a/node_modules/nanoid/index.js b/node_modules/nanoid/index.js
index 21e155f..8b3139b 100644
--- a/node_modules/nanoid/index.js
+++ b/node_modules/nanoid/index.js
@@ -1,32 +1,15 @@
-import crypto from 'crypto'
 import { urlAlphabet } from './url-alphabet/index.js'
-const POOL_SIZE_MULTIPLIER = 128
-let pool, poolOffset
-let fillPool = bytes => {
-  if (!pool || pool.length < bytes) {
-    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)
-    crypto.randomFillSync(pool)
-    poolOffset = 0
-  } else if (poolOffset + bytes > pool.length) {
-    crypto.randomFillSync(pool)
-    poolOffset = 0
-  }
-  poolOffset += bytes
-}
-let random = bytes => {
-  fillPool((bytes -= 0))
-  return pool.subarray(poolOffset - bytes, poolOffset)
-}
+let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
 let customRandom = (alphabet, defaultSize, getRandom) => {
-  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
-  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)
+  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
+  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
   return (size = defaultSize) => {
     let id = ''
     while (true) {
       let bytes = getRandom(step)
-      let i = step
-      while (i--) {
-        id += alphabet[bytes[i] & mask] || ''
+      let j = step
+      while (j--) {
+        id += alphabet[bytes[j] & mask] || ''
         if (id.length === size) return id
       }
     }
@@ -34,12 +17,18 @@ let customRandom = (alphabet, defaultSize, getRandom) => {
 }
 let customAlphabet = (alphabet, size = 21) =>
   customRandom(alphabet, size, random)
-let nanoid = (size = 21) => {
-  fillPool((size -= 0))
-  let id = ''
-  for (let i = poolOffset - size; i < poolOffset; i++) {
-    id += urlAlphabet[pool[i] & 63]
-  }
-  return id
-}
+let nanoid = (size = 21) =>
+  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
+    byte &= 63
+    if (byte < 36) {
+      id += byte.toString(36)
+    } else if (byte < 62) {
+      id += (byte - 26).toString(36).toUpperCase()
+    } else if (byte > 62) {
+      id += '-'
+    } else {
+      id += '_'
+    }
+    return id
+  }, '')
 export { nanoid, customAlphabet, customRandom, urlAlphabet, random }
